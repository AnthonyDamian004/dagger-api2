import ts from "typescript";
import { UnknownDaggerError } from "../../../common/errors/UnknownDaggerError.js";
import { Argument } from "./argument.js";
import { serializeType } from "../serialize.js";
import { typeNameToTypedef } from "../utils.js";
const METHOD_DECORATOR = "func";
/**
 * Method is an abstraction of a function or method.
 *
 * This aims to simplify and adds clarity to how we analyse the code and using
 * clear accessor.
 */
export class Method {
    checker;
    method;
    symbol;
    signature;
    decorator;
    /**
     * Create a new Method instance.
     *
     * @param checker Checker to use to introspect the method.
     * @param method The method to introspect.
     *
     * @throws UnknownDaggerError If the method doesn't have any symbol.
     * @throws UnknownDaggerError If the method doesn't have any signature.
     */
    constructor(checker, method) {
        this.checker = checker;
        this.method = method;
        const methodSymbol = checker.getSymbolAtLocation(method.name);
        if (!methodSymbol) {
            throw new UnknownDaggerError(`could not get method symbol: ${method.name.getText()}`, {});
        }
        this.symbol = methodSymbol;
        const signature = checker.getSignatureFromDeclaration(method);
        if (!signature) {
            throw new UnknownDaggerError(`could not get method signature: ${method.name.getText()}`, {});
        }
        this.signature = signature;
        this.decorator = ts.getDecorators(method)?.find((d) => {
            if (ts.isCallExpression(d.expression)) {
                return d.expression.expression.getText() === METHOD_DECORATOR;
            }
            return false;
        });
    }
    get name() {
        return this.symbol.getName();
    }
    get description() {
        return ts.displayPartsToString(this.symbol.getDocumentationComment(this.checker));
    }
    /**
     * Return the alias of the method if it has one.
     */
    get alias() {
        if (!this.decorator) {
            return undefined;
        }
        const expression = this.decorator.expression;
        const aliasArg = expression.arguments[0];
        if (!aliasArg) {
            return undefined;
        }
        return JSON.parse(aliasArg.getText().replace(/'/g, '"'));
    }
    get arguments() {
        return this.signature.parameters.reduce((acc, param) => {
            const argument = new Argument(this.checker, param);
            acc[argument.name] = argument;
            return acc;
        }, {});
    }
    /**
     * Return the type of the return value in a Dagger TypeDef format.
     */
    get returnType() {
        return typeNameToTypedef(serializeType(this.checker, this.signature.getReturnType()));
    }
    get typeDef() {
        return {
            name: this.name,
            description: this.description,
            alias: this.alias,
            args: Object.entries(this.arguments).reduce((acc, [name, arg]) => {
                acc[name] = arg.typeDef;
                return acc;
            }, {}),
            returnType: this.returnType,
        };
    }
    toJSON() {
        return {
            name: this.name,
            description: this.description,
            alias: this.alias,
            arguments: this.arguments,
            returnType: this.returnType,
        };
    }
    getArgOrder() {
        return Object.keys(this.arguments);
    }
}
