import ts from "typescript";
import { UnknownDaggerError } from "../../../common/errors/UnknownDaggerError.js";
import { serializeType } from "../serialize.js";
import { typeNameToTypedef } from "../utils.js";
const PROPERTY_DECORATOR = "field";
/**
 * Property is an abstraction of a class property.
 *
 * This aims to simplify and adds clarity to how we analyse the code and using
 * clear accessor.
 */
export class Property {
    symbol;
    checker;
    property;
    decorator;
    /**
     *
     * @param checker Checker to use to introspect the property.
     * @param property The property to introspect.
     *
     * @throws UnknownDaggerError If the property doesn't have any symbol.
     */
    constructor(checker, property) {
        this.checker = checker;
        this.property = property;
        const propertySymbol = checker.getSymbolAtLocation(property.name);
        if (!propertySymbol) {
            throw new UnknownDaggerError(`could not get property symbol: ${property.name.getText()}`, {});
        }
        this.symbol = propertySymbol;
        this.decorator = ts.getDecorators(property)?.find((d) => {
            if (ts.isCallExpression(d.expression)) {
                return d.expression.expression.getText() === PROPERTY_DECORATOR;
            }
            return false;
        });
    }
    get name() {
        return this.property.name.getText();
    }
    get description() {
        return ts.displayPartsToString(this.symbol.getDocumentationComment(this.checker));
    }
    /**
     * Return the alias of the property if it has one.
     */
    get alias() {
        if (!this.decorator) {
            return undefined;
        }
        const expression = this.decorator.expression;
        const aliasArg = expression.arguments[0];
        if (!aliasArg) {
            return undefined;
        }
        return JSON.parse(aliasArg.getText().replace(/'/g, '"'));
    }
    /**
     * Return the type of the property in a Dagger TypeDef format.
     */
    get type() {
        if (!this.symbol.valueDeclaration) {
            throw new UnknownDaggerError("could not find symbol value declaration", {});
        }
        const type = this.checker.getTypeOfSymbolAtLocation(this.symbol, this.symbol.valueDeclaration);
        const typeName = serializeType(this.checker, type);
        return typeNameToTypedef(typeName);
    }
    get isExposed() {
        return this.decorator !== undefined;
    }
    // TODO(TomChv): replace with `ToJson` method
    // after the refactor is complete.
    get typeDef() {
        return {
            name: this.name,
            description: this.description,
            alias: this.alias,
            typeDef: this.type,
            isExposed: this.isExposed,
        };
    }
    toJSON() {
        return {
            name: this.name,
            description: this.description,
            alias: this.alias,
            type: this.type,
            isExposed: this.isExposed,
        };
    }
}
